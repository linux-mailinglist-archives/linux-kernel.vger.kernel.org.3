Return-Path: <linux-kernel-owner@vger.kernel.org>
X-Original-To: lists+linux-kernel@lfdr.de
Delivered-To: lists+linux-kernel@lfdr.de
Received: from out1.vger.email (out1.vger.email [IPv6:2620:137:e000::1:20])
	by mail.lfdr.de (Postfix) with ESMTP id 57F8451DF01
	for <lists+linux-kernel@lfdr.de>; Fri,  6 May 2022 20:20:28 +0200 (CEST)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S235427AbiEFSYE (ORCPT <rfc822;lists+linux-kernel@lfdr.de>);
        Fri, 6 May 2022 14:24:04 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:43628 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1386409AbiEFSXe (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Fri, 6 May 2022 14:23:34 -0400
Received: from dfw.source.kernel.org (dfw.source.kernel.org [IPv6:2604:1380:4641:c500::1])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id E1B7D6E8F6;
        Fri,  6 May 2022 11:19:50 -0700 (PDT)
Received: from smtp.kernel.org (relay.kernel.org [52.25.139.140])
        (using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
        (No client certificate requested)
        by dfw.source.kernel.org (Postfix) with ESMTPS id 6FB486211D;
        Fri,  6 May 2022 18:19:50 +0000 (UTC)
Received: by smtp.kernel.org (Postfix) with ESMTPSA id AB7BCC385A9;
        Fri,  6 May 2022 18:19:49 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=kernel.org;
        s=k20201202; t=1651861189;
        bh=F8OZZkP2VCHLM+mFrp5QDGv1xHS8ckfdGAQvYzcVY7Y=;
        h=Date:From:To:Cc:Subject:In-Reply-To:References:From;
        b=CxFcRt2W8R/2CfHJ1kJIK6DpbkFRyRblymXIh7LUrOVMd5W11l1shKAC2BQG8nG8G
         QQupTw66h7pCGhAEjkpyG42MlPdQnclc1sSudXsVzmIRyOOd8FjgsVGmRRWWV+QUma
         rD4pdd+8ByoVzetqrxsKMaITP6PijA8lofpp9xr/wRlhC1gXGSeefovRsyUk65Wcva
         /IMS8efd5u+f/saSw8uISjQPWH0nyeD+eetTf5XMBXb5UzhyDJvo8oIrieAqA0BJyC
         rmEhLVU3RAdqbuLnm+E4zgE9ghOWubRqDAvEiRBlk/Q8lUkaHzzkBWOQdhCp5YXwe7
         IQUyzm4DgbkxA==
Received: from sofa.misterjones.org ([185.219.108.64] helo=why.misterjones.org)
        by disco-boy.misterjones.org with esmtpsa  (TLS1.3) tls TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
        (Exim 4.94.2)
        (envelope-from <maz@kernel.org>)
        id 1nn2YN-009X4h-4G; Fri, 06 May 2022 19:19:47 +0100
Date:   Fri, 06 May 2022 19:19:46 +0100
Message-ID: <87mtfu7ccd.wl-maz@kernel.org>
From:   Marc Zyngier <maz@kernel.org>
To:     Pali =?UTF-8?B?Um9ow6Fy?= <pali@kernel.org>
Cc:     Thomas Gleixner <tglx@linutronix.de>,
        Rob Herring <robh+dt@kernel.org>,
        Bjorn Helgaas <bhelgaas@google.com>,
        Andrew Lunn <andrew@lunn.ch>,
        Gregory Clement <gregory.clement@bootlin.com>,
        Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>,
        Thomas Petazzoni <thomas.petazzoni@bootlin.com>,
        Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>,
        Krzysztof =?UTF-8?B?V2lsY3p5xYRza2k=?= <kw@linux.com>,
        Marek =?UTF-8?B?QmVow7pu?= <kabel@kernel.org>,
        linux-kernel@vger.kernel.org, devicetree@vger.kernel.org,
        linux-pci@vger.kernel.org, linux-arm-kernel@lists.infradead.org
Subject: Re: [PATCH 2/6] irqchip/armada-370-xp: Implement SoC Error interrupts
In-Reply-To: <20220506134029.21470-3-pali@kernel.org>
References: <20220506134029.21470-1-pali@kernel.org>
        <20220506134029.21470-3-pali@kernel.org>
User-Agent: Wanderlust/2.15.9 (Almost Unreal) SEMI-EPG/1.14.7 (Harue)
 FLIM-LB/1.14.9 (=?UTF-8?B?R29qxY0=?=) APEL-LB/10.8 EasyPG/1.0.0 Emacs/27.1
 (x86_64-pc-linux-gnu) MULE/6.0 (HANACHIRUSATO)
MIME-Version: 1.0 (generated by SEMI-EPG 1.14.7 - "Harue")
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable
X-SA-Exim-Connect-IP: 185.219.108.64
X-SA-Exim-Rcpt-To: pali@kernel.org, tglx@linutronix.de, robh+dt@kernel.org, bhelgaas@google.com, andrew@lunn.ch, gregory.clement@bootlin.com, sebastian.hesselbarth@gmail.com, thomas.petazzoni@bootlin.com, lorenzo.pieralisi@arm.com, kw@linux.com, kabel@kernel.org, linux-kernel@vger.kernel.org, devicetree@vger.kernel.org, linux-pci@vger.kernel.org, linux-arm-kernel@lists.infradead.org
X-SA-Exim-Mail-From: maz@kernel.org
X-SA-Exim-Scanned: No (on disco-boy.misterjones.org); SAEximRunCond expanded to false
X-Spam-Status: No, score=-7.7 required=5.0 tests=BAYES_00,DKIMWL_WL_HIGH,
        DKIM_SIGNED,DKIM_VALID,DKIM_VALID_AU,DKIM_VALID_EF,RCVD_IN_DNSWL_HI,
        SPF_HELO_NONE,SPF_PASS,T_SCC_BODY_TEXT_LINE autolearn=ham
        autolearn_force=no version=3.4.6
X-Spam-Checker-Version: SpamAssassin 3.4.6 (2021-04-09) on
        lindbergh.monkeyblade.net
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

On Fri, 06 May 2022 14:40:25 +0100,
Pali Roh=C3=A1r <pali@kernel.org> wrote:
>=20
> MPIC IRQ 4 is used as SoC Error Summary interrupt and provides access to
> another hierarchy of SoC Error interrupts. Implement a new IRQ chip and
> domain for accessing this IRQ hierarchy.
>=20
> Signed-off-by: Pali Roh=C3=A1r <pali@kernel.org>
> ---
>  drivers/irqchip/irq-armada-370-xp.c | 213 +++++++++++++++++++++++++++-
>  1 file changed, 210 insertions(+), 3 deletions(-)
>=20
> diff --git a/drivers/irqchip/irq-armada-370-xp.c b/drivers/irqchip/irq-ar=
mada-370-xp.c
> index ebd76ea1c69b..71578b65f5c8 100644
> --- a/drivers/irqchip/irq-armada-370-xp.c
> +++ b/drivers/irqchip/irq-armada-370-xp.c
> @@ -117,6 +117,8 @@
>  /* Registers relative to main_int_base */
>  #define ARMADA_370_XP_INT_CONTROL		(0x00)
>  #define ARMADA_370_XP_SW_TRIG_INT_OFFS		(0x04)
> +#define ARMADA_370_XP_INT_SOC_ERR_0_CAUSE_OFFS	(0x20)
> +#define ARMADA_370_XP_INT_SOC_ERR_1_CAUSE_OFFS	(0x24)
>  #define ARMADA_370_XP_INT_SET_ENABLE_OFFS	(0x30)
>  #define ARMADA_370_XP_INT_CLEAR_ENABLE_OFFS	(0x34)
>  #define ARMADA_370_XP_INT_SOURCE_CTL(irq)	(0x100 + irq*4)
> @@ -130,6 +132,8 @@
>  #define ARMADA_370_XP_CPU_INTACK_OFFS		(0x44)
>  #define ARMADA_370_XP_INT_SET_MASK_OFFS		(0x48)
>  #define ARMADA_370_XP_INT_CLEAR_MASK_OFFS	(0x4C)
> +#define ARMADA_370_XP_INT_SOC_ERR_0_MASK_OFF	(0x50)
> +#define ARMADA_370_XP_INT_SOC_ERR_1_MASK_OFF	(0x54)
>  #define ARMADA_370_XP_INT_FABRIC_MASK_OFFS	(0x54)
>  #define ARMADA_370_XP_INT_CAUSE_PERF(cpu)	(1 << cpu)
> =20
> @@ -146,6 +150,8 @@
>  static void __iomem *per_cpu_int_base;
>  static void __iomem *main_int_base;
>  static struct irq_domain *armada_370_xp_mpic_domain;
> +static struct irq_domain *armada_370_xp_soc_err_domain;
> +static unsigned int soc_err_irq_num_regs;
>  static u32 doorbell_mask_reg;
>  static int parent_irq;
>  #ifdef CONFIG_PCI_MSI
> @@ -156,6 +162,8 @@ static DEFINE_MUTEX(msi_used_lock);
>  static phys_addr_t msi_doorbell_addr;
>  #endif
> =20
> +static void armada_370_xp_soc_err_irq_unmask(struct irq_data *d);
> +
>  static inline bool is_percpu_irq(irq_hw_number_t irq)
>  {
>  	if (irq <=3D ARMADA_370_XP_MAX_PER_CPU_IRQS)
> @@ -509,6 +517,27 @@ static void armada_xp_mpic_reenable_percpu(void)
>  		armada_370_xp_irq_unmask(data);
>  	}
> =20
> +	/* Re-enable per-CPU SoC Error interrupts that were enabled before susp=
end */
> +	for (irq =3D 0; irq < soc_err_irq_num_regs * 32; irq++) {
> +		struct irq_data *data;
> +		int virq;
> +
> +		virq =3D irq_linear_revmap(armada_370_xp_soc_err_domain, irq);
> +		if (virq =3D=3D 0)
> +			continue;
> +
> +		data =3D irq_get_irq_data(virq);
> +
> +		if (!irq_percpu_is_enabled(virq))
> +			continue;
> +
> +		armada_370_xp_soc_err_irq_unmask(data);
> +	}

So you do this loop and all these lookups, both here and in the resume
function (duplicated code!) just to be able to call the unmask
function?  This would be better served by two straight writes of the
mask register, which you'd conveniently save on suspend.

Yes, you have only duplicated the existing logic. But surely there is
something better to do.

> +
> +	/* Unmask summary SoC Error Interrupt */
> +	if (soc_err_irq_num_regs > 0)
> +		writel(4, per_cpu_int_base + ARMADA_370_XP_INT_CLEAR_MASK_OFFS);
> +
>  	ipi_resume();
>  }
> =20
> @@ -546,8 +575,8 @@ static struct irq_chip armada_370_xp_irq_chip =3D {
>  static int armada_370_xp_mpic_irq_map(struct irq_domain *h,
>  				      unsigned int virq, irq_hw_number_t hw)
>  {
> -	/* IRQs 0 and 1 cannot be mapped, they are handled internally */
> -	if (hw <=3D 1)
> +	/* IRQs 0, 1 and 4 cannot be mapped, they are handled internally */
> +	if (hw <=3D 1 || hw =3D=3D 4)
>  		return -EINVAL;
> =20
>  	armada_370_xp_irq_mask(irq_get_irq_data(virq));
> @@ -577,6 +606,99 @@ static const struct irq_domain_ops armada_370_xp_mpi=
c_irq_ops =3D {
>  	.xlate =3D irq_domain_xlate_onecell,
>  };
> =20
> +static DEFINE_RAW_SPINLOCK(armada_370_xp_soc_err_lock);
> +
> +static void armada_370_xp_soc_err_irq_mask(struct irq_data *d)
> +{
> +	irq_hw_number_t hwirq =3D irqd_to_hwirq(d);
> +	u32 reg, mask;
> +
> +	reg =3D hwirq >=3D 32 ? ARMADA_370_XP_INT_SOC_ERR_1_MASK_OFF
> +			  : ARMADA_370_XP_INT_SOC_ERR_0_MASK_OFF;
> +
> +	raw_spin_lock(&armada_370_xp_soc_err_lock);
> +	mask =3D readl(per_cpu_int_base + reg);
> +	mask &=3D ~BIT(hwirq % 32);
> +	writel(mask, per_cpu_int_base + reg);
> +	raw_spin_unlock(&armada_370_xp_soc_err_lock);
> +}
> +
> +static void armada_370_xp_soc_err_irq_unmask(struct irq_data *d)
> +{
> +	irq_hw_number_t hwirq =3D irqd_to_hwirq(d);
> +	u32 reg, mask;
> +
> +	reg =3D hwirq >=3D 32 ? ARMADA_370_XP_INT_SOC_ERR_1_MASK_OFF
> +			  : ARMADA_370_XP_INT_SOC_ERR_0_MASK_OFF;
> +
> +	raw_spin_lock(&armada_370_xp_soc_err_lock);
> +	mask =3D readl(per_cpu_int_base + reg);
> +	mask |=3D BIT(hwirq % 32);
> +	writel(mask, per_cpu_int_base + reg);
> +	raw_spin_unlock(&armada_370_xp_soc_err_lock);
> +}
> +
> +static int armada_370_xp_soc_err_irq_mask_on_cpu(void *par)
> +{
> +	struct irq_data *d =3D par;
> +	armada_370_xp_soc_err_irq_mask(d);
> +	return 0;
> +}
> +
> +static int armada_370_xp_soc_err_irq_unmask_on_cpu(void *par)
> +{
> +	struct irq_data *d =3D par;
> +	armada_370_xp_soc_err_irq_unmask(d);
> +	return 0;
> +}
> +
> +static int armada_xp_soc_err_irq_set_affinity(struct irq_data *d,
> +					      const struct cpumask *mask,
> +					      bool force)
> +{
> +	unsigned int cpu;
> +
> +	cpus_read_lock();
> +
> +	/* First disable IRQ on all cores */
> +	for_each_online_cpu(cpu)
> +		smp_call_on_cpu(cpu, armada_370_xp_soc_err_irq_mask_on_cpu, d, true);
> +
> +	/* Select a single core from the affinity mask which is online */
> +	cpu =3D cpumask_any_and(mask, cpu_online_mask);
> +	smp_call_on_cpu(cpu, armada_370_xp_soc_err_irq_unmask_on_cpu, d, true);
> +
> +	cpus_read_unlock();
> +
> +	irq_data_update_effective_affinity(d, cpumask_of(cpu));
> +
> +	return IRQ_SET_MASK_OK;
> +}

Aren't these per-CPU interrupts anyway? What does it mean to set their
affinity? /me rolls eyes...

> +
> +static struct irq_chip armada_370_xp_soc_err_irq_chip =3D {
> +	.name =3D "MPIC SOC",
> +	.irq_mask =3D armada_370_xp_soc_err_irq_mask,
> +	.irq_unmask =3D armada_370_xp_soc_err_irq_unmask,
> +	.irq_set_affinity =3D armada_xp_soc_err_irq_set_affinity,
> +};
> +
> +static int armada_370_xp_soc_err_irq_map(struct irq_domain *h,
> +					 unsigned int virq, irq_hw_number_t hw)
> +{
> +	armada_370_xp_soc_err_irq_mask(irq_get_irq_data(virq));
> +	irq_set_status_flags(virq, IRQ_LEVEL);
> +	irq_set_percpu_devid(virq);
> +	irq_set_chip_and_handler(virq, &armada_370_xp_soc_err_irq_chip,
> +				 handle_percpu_devid_irq);
> +	irq_set_probe(virq);
> +	return 0;
> +}
> +
> +static const struct irq_domain_ops armada_370_xp_soc_err_irq_ops =3D {
> +	.map =3D armada_370_xp_soc_err_irq_map,
> +	.xlate =3D irq_domain_xlate_onecell,
> +};
> +
>  #ifdef CONFIG_PCI_MSI
>  static void armada_370_xp_handle_msi_irq(struct pt_regs *regs, bool is_c=
hained)
>  {
> @@ -605,6 +727,32 @@ static void armada_370_xp_handle_msi_irq(struct pt_r=
egs *regs, bool is_chained)
>  static void armada_370_xp_handle_msi_irq(struct pt_regs *r, bool b) {}
>  #endif
> =20
> +static void armada_370_xp_handle_soc_err_irq(void)
> +{
> +	unsigned long status, bit;
> +	u32 mask, cause;
> +
> +	if (soc_err_irq_num_regs < 1)
> +		return;
> +
> +	mask =3D readl(per_cpu_int_base + ARMADA_370_XP_INT_SOC_ERR_0_MASK_OFF);
> +	cause =3D readl(main_int_base + ARMADA_370_XP_INT_SOC_ERR_0_CAUSE_OFFS);
> +	status =3D cause & mask;
> +
> +	for_each_set_bit(bit, &status, 32)
> +		generic_handle_domain_irq(armada_370_xp_soc_err_domain, bit);
> +
> +	if (soc_err_irq_num_regs < 2)
> +		return;
> +
> +	mask =3D readl(per_cpu_int_base + ARMADA_370_XP_INT_SOC_ERR_1_MASK_OFF);
> +	cause =3D readl(main_int_base + ARMADA_370_XP_INT_SOC_ERR_1_CAUSE_OFFS);
> +	status =3D cause & mask;
> +
> +	for_each_set_bit(bit, &status, 32)
> +		generic_handle_domain_irq(armada_370_xp_soc_err_domain, bit + 32);
> +}
> +
>  static void armada_370_xp_mpic_handle_cascade_irq(struct irq_desc *desc)
>  {
>  	struct irq_chip *chip =3D irq_desc_get_chip(desc);
> @@ -630,6 +778,11 @@ static void armada_370_xp_mpic_handle_cascade_irq(st=
ruct irq_desc *desc)
>  			continue;
>  		}
> =20
> +		if (irqn =3D=3D 4) {
> +			armada_370_xp_handle_soc_err_irq();
> +			continue;
> +		}
> +
>  		generic_handle_domain_irq(armada_370_xp_mpic_domain, irqn);
>  	}
> =20
> @@ -649,7 +802,7 @@ armada_370_xp_handle_irq(struct pt_regs *regs)
>  		if (irqnr > 1022)
>  			break;
> =20
> -		if (irqnr > 1) {
> +		if (irqnr > 1 && irqnr !=3D 4) {
>  			generic_handle_domain_irq(armada_370_xp_mpic_domain,
>  						  irqnr);
>  			continue;
> @@ -659,6 +812,10 @@ armada_370_xp_handle_irq(struct pt_regs *regs)
>  		if (irqnr =3D=3D 1)
>  			armada_370_xp_handle_msi_irq(regs, false);
> =20
> +		/* SoC Error handling */
> +		if (irqnr =3D=3D 4)
> +			armada_370_xp_handle_soc_err_irq();
> +
>  #ifdef CONFIG_SMP
>  		/* IPI Handling */
>  		if (irqnr =3D=3D 0) {
> @@ -722,6 +879,26 @@ static void armada_370_xp_mpic_resume(void)
>  		}
>  	}
> =20
> +	/* Re-enable per-CPU SoC Error interrupts */
> +	for (irq =3D 0; irq < soc_err_irq_num_regs * 32; irq++) {
> +		struct irq_data *data;
> +		int virq;
> +
> +		virq =3D irq_linear_revmap(armada_370_xp_soc_err_domain, irq);
> +		if (virq =3D=3D 0)
> +			continue;
> +
> +		data =3D irq_get_irq_data(virq);
> +
> +		/*
> +		 * Re-enable on the current CPU,
> +		 * armada_xp_mpic_reenable_percpu() will take
> +		 * care of secondary CPUs when they come up.
> +		 */
> +		if (irq_percpu_is_enabled(virq))
> +			armada_370_xp_soc_err_irq_unmask(data);
> +	}

As I said above, this is duplicated code that should be replaced with
a simple write to the corresponding MMIO registers.

> +
>  	/* Reconfigure doorbells for IPIs and MSIs */
>  	writel(doorbell_mask_reg,
>  	       per_cpu_int_base + ARMADA_370_XP_IN_DRBEL_MSK_OFFS);
> @@ -730,6 +907,10 @@ static void armada_370_xp_mpic_resume(void)
>  	if (doorbell_mask_reg & PCI_MSI_DOORBELL_MASK)
>  		writel(1, per_cpu_int_base + ARMADA_370_XP_INT_CLEAR_MASK_OFFS);
> =20
> +	/* Unmask summary SoC Error Interrupt */
> +	if (soc_err_irq_num_regs > 0)
> +		writel(4, per_cpu_int_base + ARMADA_370_XP_INT_CLEAR_MASK_OFFS);

Magic value?

Also, writing to this register tends to indicate that the whole thing
should really be a chained irqchip... Maybe that's overkill in this
instance, but the whole thing is rather oddly architected.

> +
>  	ipi_resume();
>  }
> =20
> @@ -742,6 +923,7 @@ static int __init armada_370_xp_mpic_of_init(struct d=
evice_node *node,
>  					     struct device_node *parent)
>  {
>  	struct resource main_int_res, per_cpu_int_res;
> +	struct device_node *soc_err_node;
>  	int nr_irqs, i;
>  	u32 control;
> =20
> @@ -775,12 +957,37 @@ static int __init armada_370_xp_mpic_of_init(struct=
 device_node *node,
>  	BUG_ON(!armada_370_xp_mpic_domain);
>  	irq_domain_update_bus_token(armada_370_xp_mpic_domain, DOMAIN_BUS_WIRED=
);
> =20
> +	soc_err_node =3D of_get_next_child(node, NULL);
> +	if (!soc_err_node) {
> +		pr_warn("Missing SoC Error Interrupt Controller node\n");
> +		pr_warn("Extended interrupts are not supported\n");
> +	} else {
> +		pr_info("Registering MPIC SoC Error Interrupt Controller\n");
> +		/*
> +		 * Armada 370 and XP have only 32 SoC Error IRQs in one register
> +		 * and other Armada platforms have 64 IRQs in two registers.
> +		 */
> +		soc_err_irq_num_regs =3D
> +			of_machine_is_compatible("marvell,armada-370-xp") ? 1 : 2;

Don't you have an actual compatible string for the interrupt
controller?  It seems odd to rely on the SoC name.

> +		armada_370_xp_soc_err_domain =3D
> +			irq_domain_add_hierarchy(armada_370_xp_mpic_domain, 0,
> +						 soc_err_irq_num_regs * 32,
> +						 soc_err_node,
> +						 &armada_370_xp_soc_err_irq_ops,
> +						 NULL);
> +		BUG_ON(!armada_370_xp_soc_err_domain);
> +	}
> +
>  	/* Setup for the boot CPU */
>  	armada_xp_mpic_perf_init();
>  	armada_xp_mpic_smp_cpu_init();
> =20
>  	armada_370_xp_msi_init(node, main_int_res.start);
> =20
> +	/* Unmask summary SoC Error Interrupt */
> +	if (soc_err_irq_num_regs > 0)
> +		writel(4, per_cpu_int_base + ARMADA_370_XP_INT_CLEAR_MASK_OFFS);
> +

Magic value, duplicated this time?

>  	parent_irq =3D irq_of_parse_and_map(node, 0);
>  	if (parent_irq <=3D 0) {
>  		irq_set_default_host(armada_370_xp_mpic_domain);
> --=20
> 2.20.1
>=20
>=20

	M.

--=20
Without deviation from the norm, progress is not possible.
