Return-Path: <linux-kernel-owner@vger.kernel.org>
X-Original-To: lists+linux-kernel@lfdr.de
Delivered-To: lists+linux-kernel@lfdr.de
Received: from out1.vger.email (out1.vger.email [IPv6:2620:137:e000::1:20])
	by mail.lfdr.de (Postfix) with ESMTP id 8806553E974
	for <lists+linux-kernel@lfdr.de>; Mon,  6 Jun 2022 19:08:41 +0200 (CEST)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S233385AbiFFKDQ (ORCPT <rfc822;lists+linux-kernel@lfdr.de>);
        Mon, 6 Jun 2022 06:03:16 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:57184 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S233374AbiFFKDA (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Mon, 6 Jun 2022 06:03:00 -0400
Received: from dfw.source.kernel.org (dfw.source.kernel.org [IPv6:2604:1380:4641:c500::1])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id A99322629
        for <linux-kernel@vger.kernel.org>; Mon,  6 Jun 2022 03:02:58 -0700 (PDT)
Received: from smtp.kernel.org (relay.kernel.org [52.25.139.140])
        (using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
        (No client certificate requested)
        by dfw.source.kernel.org (Postfix) with ESMTPS id B9CD961281
        for <linux-kernel@vger.kernel.org>; Mon,  6 Jun 2022 10:02:57 +0000 (UTC)
Received: by smtp.kernel.org (Postfix) with ESMTPSA id D0771C3411C;
        Mon,  6 Jun 2022 10:02:56 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=kernel.org;
        s=k20201202; t=1654509777;
        bh=VIMr6EZ6uaNyIqN8/65VWECveYQWTgyU1T8AwlDnc9E=;
        h=Date:From:To:Cc:Subject:In-Reply-To:References:From;
        b=n5DnSfSo+f903mJNKZr/4LEuJl9Y16fBY1IoPenOQurUsW9qr+uCgpQHGOtERCM7j
         LL6Cuu25pMG63cb8UbUHx1WRkxddOBjqxWgtf3BvBDsX2jJIrOgYoF2zqU146cyNdV
         if2pb1pxgygQ5JQDeuLiLNIEwjOjdAAogm7bCLXxE25QoDPmJHIneJaw1OXRs7r+ub
         HZKRhU2DlF5871YRM9ryCwQwaFozK2m5ZCRKxE0JvgVWwI8TTZgSIuzskBy5cyyiLg
         tZ65gcikcfq325tAVChmy54eint2EGbkV1TcF0d97JKAZYieVmJa8wnbcMeHFGQnK9
         NVQD3FW5rQ5Vw==
Received: from sofa.misterjones.org ([185.219.108.64] helo=why.misterjones.org)
        by disco-boy.misterjones.org with esmtpsa  (TLS1.3) tls TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
        (Exim 4.94.2)
        (envelope-from <maz@kernel.org>)
        id 1ny9ZW-00FrXI-IG; Mon, 06 Jun 2022 11:02:54 +0100
Date:   Mon, 06 Jun 2022 11:02:54 +0100
Message-ID: <871qw25ctt.wl-maz@kernel.org>
From:   Marc Zyngier <maz@kernel.org>
To:     Jianmin Lv <lvjianmin@loongson.cn>
Cc:     Thomas Gleixner <tglx@linutronix.de>, linux-kernel@vger.kernel.org,
        Xuefeng Li <lixuefeng@loongson.cn>,
        Huacai Chen <chenhuacai@gmail.com>,
        Jiaxun Yang <jiaxun.yang@flygoat.com>,
        Huacai Chen <chenhuacai@loongson.cn>,
        Hanjun Guo <guohanjun@huawei.com>,
        Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Subject: Re: [PATCH RFC V2 02/10] irqchip: Add LoongArch CPU interrupt controller support
In-Reply-To: <1c7b1ee5-3f1e-c090-fb2e-65741de76a9f@loongson.cn>
References: <1653649335-11998-1-git-send-email-lvjianmin@loongson.cn>
        <1653649335-11998-3-git-send-email-lvjianmin@loongson.cn>
        <87bkvf56wg.wl-maz@kernel.org>
        <64990891.8322.18119c6d212.Coremail.lvjianmin@loongson.cn>
        <87a6ax6c0n.wl-maz@kernel.org>
        <1c7b1ee5-3f1e-c090-fb2e-65741de76a9f@loongson.cn>
User-Agent: Wanderlust/2.15.9 (Almost Unreal) SEMI-EPG/1.14.7 (Harue)
 FLIM-LB/1.14.9 (=?UTF-8?B?R29qxY0=?=) APEL-LB/10.8 EasyPG/1.0.0 Emacs/27.1
 (x86_64-pc-linux-gnu) MULE/6.0 (HANACHIRUSATO)
MIME-Version: 1.0 (generated by SEMI-EPG 1.14.7 - "Harue")
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable
X-SA-Exim-Connect-IP: 185.219.108.64
X-SA-Exim-Rcpt-To: lvjianmin@loongson.cn, tglx@linutronix.de, linux-kernel@vger.kernel.org, lixuefeng@loongson.cn, chenhuacai@gmail.com, jiaxun.yang@flygoat.com, chenhuacai@loongson.cn, guohanjun@huawei.com, lorenzo.pieralisi@arm.com
X-SA-Exim-Mail-From: maz@kernel.org
X-SA-Exim-Scanned: No (on disco-boy.misterjones.org); SAEximRunCond expanded to false
X-Spam-Status: No, score=-8.3 required=5.0 tests=BAYES_00,DKIMWL_WL_HIGH,
        DKIM_SIGNED,DKIM_VALID,DKIM_VALID_AU,DKIM_VALID_EF,RCVD_IN_DNSWL_HI,
        SPF_HELO_NONE,SPF_PASS,T_SCC_BODY_TEXT_LINE autolearn=ham
        autolearn_force=no version=3.4.6
X-Spam-Checker-Version: SpamAssassin 3.4.6 (2021-04-09) on
        lindbergh.monkeyblade.net
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

+ Lorenzo and Hanjun who maintain the ACPI irq code

On Thu, 02 Jun 2022 04:16:30 +0100,
Jianmin Lv <lvjianmin@loongson.cn> wrote:
>=20
> >>>> +
> >>>> +int acpi_gsi_to_irq(u32 gsi, unsigned int *irqp)
> >>>> +{
> >>>> +	if (irqp !=3D NULL)
> >>>> +		*irqp =3D acpi_register_gsi(NULL, gsi, -1, -1);
> >>>> +	return (*irqp >=3D 0) ? 0 : -EINVAL;
> >>>> +}
> >>>> +EXPORT_SYMBOL_GPL(acpi_gsi_to_irq);
> >>>> +
> >>>> +int acpi_isa_irq_to_gsi(unsigned int isa_irq, u32 *gsi)
> >>>> +{
> >>>> +	if (gsi)
> >>>> +		*gsi =3D isa_irq;
> >>>> +	return 0;
> >>>> +}
> >>>> +
> >>>> +/*
> >>>> + * success: return IRQ number (>=3D0)
> >>>> + * failure: return &lt; 0
> >>>> + */
> >>>> +int acpi_register_gsi(struct device *dev, u32 gsi, int trigger, int=
 polarity)
> >>>> +{
> >>>> +	int id;
> >>>> +	struct irq_fwspec fwspec;
> >>>> +
> >>>> +	switch (gsi) {
> >>>> +	case GSI_MIN_CPU_IRQ ... GSI_MAX_CPU_IRQ:
> >>>> +		fwspec.fwnode =3D liointc_domain->fwnode;
> >>>> +		fwspec.param[0] =3D gsi - GSI_MIN_CPU_IRQ;
> >>>> +		fwspec.param_count =3D 1;
> >>>> +
> >>>> +		return irq_create_fwspec_mapping(&amp;fwspec);
> >>>> +
> >>>> +	case GSI_MIN_LPC_IRQ ... GSI_MAX_LPC_IRQ:
> >>>> +		if (!pch_lpc_domain)
> >>>> +			return -EINVAL;
> >>>> +
> >>>> +		fwspec.fwnode =3D pch_lpc_domain->fwnode;
> >>>> +		fwspec.param[0] =3D gsi - GSI_MIN_LPC_IRQ;
> >>>> +		fwspec.param[1] =3D acpi_dev_get_irq_type(trigger, polarity);
> >>>> +		fwspec.param_count =3D 2;
> >>>> +
> >>>> +		return irq_create_fwspec_mapping(&amp;fwspec);
> >>>> +
> >>>> +	case GSI_MIN_PCH_IRQ ... GSI_MAX_PCH_IRQ:
> >>>> +		id =3D find_pch_pic(gsi);
> >>>> +		if (id &lt; 0)
> >>>> +			return -EINVAL;
> >>>> +
> >>>> +		fwspec.fwnode =3D pch_pic_domain[id]->fwnode;
> >>>> +		fwspec.param[0] =3D gsi - acpi_pchpic[id]->gsi_base;
> >>>> +		fwspec.param[1] =3D IRQ_TYPE_LEVEL_HIGH;
> >>>> +		fwspec.param_count =3D 2;
> >>>> +
> >>>> +		return irq_create_fwspec_mapping(&amp;fwspec);
> >>>> +	}
> >>> So all the complexity here seems to stem from the fact that you deal
> >>> with three ranges of interrupts, managed by three different pieces of
> >>> code?
> >>>=20
> >> Yes.
> >>=20
> >>> Other architectures have similar requirements, and don't require to
> >>> re-implement a private version of the ACPI API. Instead, they expose a
> >>> single irqdomain, and deal with the various ranges internally.
> >>>=20
> >>> Clearly, not being able to reuse drivers/acpi/irq.c *is* an issue.
> >>>=20
> >> Thanks, I agree, that sounds a good and reasonable suggestion, and
> >> I'll reserach it further and reuse code from drivers/acpi/irq.c as
> >> can as possible.
> >>=20
> Hi, Marc, according to your suggestion, I carefully looked into gic
> driver of ARM, and I found one possible gsi mapping path as following:
>=20
> acpi_register_gsi /* whatever the gsi is, gic domain for ARM is only
> single domain to use.*/
> =C2=A0->irq_create_fwspec_mapping
> =C2=A0=C2=A0 ->irq_find_mapping /* return irq in the mapping of irqdomain=
 with
> fwnode_handle of acpi_gsi_domain_id if configured. */
> =C2=A0=C2=A0 ->irq_domain_alloc_irqs /* if not configured and hierarchy d=
omain */
> =C2=A0=C2=A0=C2=A0=C2=A0 ->irq_domain_alloc_irqs_hierarchy
> =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 ->domain->ops->alloc /* call gic_irq=
_domain_alloc */
> =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 ->gic_irq_domain_map /* =
handle different GSI range as
> following code: */
>=20
>=20
> =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 switch (__get_intid_range(hw))=
 {
> =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 case SGI_RANGE:
> =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 case PPI_RANGE:
> =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 case EPPI_RANGE:
> =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=
=C2=A0=C2=A0=C2=A0 irq_set_percpu_devid(irq);
> =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=
=C2=A0=C2=A0=C2=A0 irq_domain_set_info(d, irq, hw, chip, d->host_data,
> =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=
=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=
=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 handle_perc=
pu_devid_irq, NULL, NULL);
> =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=
=C2=A0=C2=A0=C2=A0 break;
>=20
> =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 case SPI_RANGE:
> =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 case ESPI_RANGE:
> =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=
=C2=A0=C2=A0=C2=A0 irq_domain_set_info(d, irq, hw, chip, d->host_data,
> =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=
=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=
=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 handle_fast=
eoi_irq, NULL, NULL);
> =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=
=C2=A0=C2=A0=C2=A0 irq_set_probe(irq);
> =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=
=C2=A0=C2=A0=C2=A0 irqd_set_single_target(irqd);
> =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=
=C2=A0=C2=A0=C2=A0 break;
>=20
> =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 case LPI_RANGE:
> =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=
=C2=A0=C2=A0=C2=A0 if (!gic_dist_supports_lpis())
> =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=
=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 return -=
EPERM;
> =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=
=C2=A0=C2=A0=C2=A0 irq_domain_set_info(d, irq, hw, chip, d->host_data,
> =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=
=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=
=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 handle_fast=
eoi_irq, NULL, NULL);
> =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=
=C2=A0=C2=A0=C2=A0 break;
>=20
> Yes, it's well for ARM by this way, and I found that only one
> domain(specified by acpi_gsi_domain_id)is used.
>=20
> But for LoongArch, different GSI range have to be handled in different
> domain(e.g. GSI for LIOINTC irqchip can be only mapped in LIOINTC
> domain.). The hwirq->irq mapping of different GSI range is stored in
> related separate domain. The reason leading to this is that an
> interrupt source is hardcodingly to connected to an interrupt vector
> for these irqchip(LIOINTC,LPC-PIC and PCH-PIC), and the interrupt
> source of them need to be configured with GSI in DSDT or
> FADT(e.g. SCI).
>=20
> If only exposing one domain for LoongArch, when calling
> irq_find_mapping in acpi_register_gsi flow, the irq is returned only
> from the domain specfied by acpi_gsi_domain_id, so I'm afraid it's
> unsuitable to expose a single domain for acpi_register_gsi.
>=20
> I'm so sorry, I really don't find a way to reuse driver/acpi/irq.c
> after my humble work.

I don't think reimplementing ACPI is the solution. What could be a
reasonable approach is a way to overload the retrieval of the
acpi_gsi_domain_id fwnode with a GSI parameter.

I hacked the following patch, which will give you an idea of what I
have in mind (only compile-tested).

Thanks,

	M.

=46rom a3fdc06a53cbcc0e6b77863aae9a7b01a0848fd0 Mon Sep 17 00:00:00 2001
From: Marc Zyngier <maz@kernel.org>
Date: Mon, 6 Jun 2022 10:49:14 +0100
Subject: [PATCH] APCI: irq: Add support for multiple GSI domains

In an unfortunate departure from the ACPI spec, the LoongArch
architecture split its GSI space across multiple interrupt
controllers.

In order to be able to reuse sthe core code and prevent
rachitectures from reinventing an already square wheel, offer
the arch code the ability to register a dispatcher function
that will return the domain fwnode for a given GSI.

The ARM GIC drivers are updated to support this (with a single
domain, as intended).

Signed-off-by: Marc Zyngier <maz@kernel.org>
Cc: Hanjun Guo <guohanjun@huawei.com>
Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
---
 drivers/acpi/irq.c           | 41 +++++++++++++++++++++++-------------
 drivers/irqchip/irq-gic-v3.c | 18 ++++++++++------
 drivers/irqchip/irq-gic.c    | 18 ++++++++++------
 include/linux/acpi.h         |  2 +-
 4 files changed, 51 insertions(+), 28 deletions(-)

diff --git a/drivers/acpi/irq.c b/drivers/acpi/irq.c
index c68e694fca26..6e1633ac1756 100644
--- a/drivers/acpi/irq.c
+++ b/drivers/acpi/irq.c
@@ -12,7 +12,7 @@
=20
 enum acpi_irq_model_id acpi_irq_model;
=20
-static struct fwnode_handle *acpi_gsi_domain_id;
+static struct fwnode_handle *(*acpi_get_gsi_domain_id)(u32 gsi);
=20
 /**
  * acpi_gsi_to_irq() - Retrieve the linux irq number for a given GSI
@@ -26,8 +26,10 @@ static struct fwnode_handle *acpi_gsi_domain_id;
  */
 int acpi_gsi_to_irq(u32 gsi, unsigned int *irq)
 {
-	struct irq_domain *d =3D irq_find_matching_fwnode(acpi_gsi_domain_id,
-							DOMAIN_BUS_ANY);
+	struct irq_domain *d;
+
+	d =3D irq_find_matching_fwnode(acpi_get_gsi_domain_id(gsi),
+				     DOMAIN_BUS_ANY);
=20
 	*irq =3D irq_find_mapping(d, gsi);
 	/*
@@ -53,12 +55,12 @@ int acpi_register_gsi(struct device *dev, u32 gsi, int =
trigger,
 {
 	struct irq_fwspec fwspec;
=20
-	if (WARN_ON(!acpi_gsi_domain_id)) {
+	fwspec.fwnode =3D acpi_get_gsi_domain_id(gsi);
+	if (WARN_ON(!fwspec.fwnode)) {
 		pr_warn("GSI: No registered irqchip, giving up\n");
 		return -EINVAL;
 	}
=20
-	fwspec.fwnode =3D acpi_gsi_domain_id;
 	fwspec.param[0] =3D gsi;
 	fwspec.param[1] =3D acpi_dev_get_irq_type(trigger, polarity);
 	fwspec.param_count =3D 2;
@@ -73,13 +75,14 @@ EXPORT_SYMBOL_GPL(acpi_register_gsi);
  */
 void acpi_unregister_gsi(u32 gsi)
 {
-	struct irq_domain *d =3D irq_find_matching_fwnode(acpi_gsi_domain_id,
-							DOMAIN_BUS_ANY);
+	struct irq_domain *d;
 	int irq;
=20
 	if (WARN_ON(acpi_irq_model =3D=3D ACPI_IRQ_MODEL_GIC && gsi < 16))
 		return;
=20
+	d =3D irq_find_matching_fwnode(acpi_get_gsi_domain_id(gsi),
+				     DOMAIN_BUS_ANY);
 	irq =3D irq_find_mapping(d, gsi);
 	irq_dispose_mapping(irq);
 }
@@ -97,7 +100,8 @@ EXPORT_SYMBOL_GPL(acpi_unregister_gsi);
  * The referenced device fwhandle or NULL on failure
  */
 static struct fwnode_handle *
-acpi_get_irq_source_fwhandle(const struct acpi_resource_source *source)
+acpi_get_irq_source_fwhandle(const struct acpi_resource_source *source,
+			     u32 gsi)
 {
 	struct fwnode_handle *result;
 	struct acpi_device *device;
@@ -105,7 +109,7 @@ acpi_get_irq_source_fwhandle(const struct acpi_resource=
_source *source)
 	acpi_status status;
=20
 	if (!source->string_length)
-		return acpi_gsi_domain_id;
+		return acpi_get_gsi_domain_id(gsi);
=20
 	status =3D acpi_get_handle(NULL, source->string_ptr, &handle);
 	if (WARN_ON(ACPI_FAILURE(status)))
@@ -194,7 +198,7 @@ static acpi_status acpi_irq_parse_one_cb(struct acpi_re=
source *ares,
 			ctx->index -=3D irq->interrupt_count;
 			return AE_OK;
 		}
-		fwnode =3D acpi_gsi_domain_id;
+		fwnode =3D acpi_get_gsi_domain_id(ctx->index);
 		acpi_irq_parse_one_match(fwnode, irq->interrupts[ctx->index],
 					 irq->triggering, irq->polarity,
 					 irq->shareable, ctx);
@@ -207,7 +211,8 @@ static acpi_status acpi_irq_parse_one_cb(struct acpi_re=
source *ares,
 			ctx->index -=3D eirq->interrupt_count;
 			return AE_OK;
 		}
-		fwnode =3D acpi_get_irq_source_fwhandle(&eirq->resource_source);
+		fwnode =3D acpi_get_irq_source_fwhandle(&eirq->resource_source,
+						      eirq->interrupts[ctx->index]);
 		acpi_irq_parse_one_match(fwnode, eirq->interrupts[ctx->index],
 					 eirq->triggering, eirq->polarity,
 					 eirq->shareable, ctx);
@@ -291,10 +296,10 @@ EXPORT_SYMBOL_GPL(acpi_irq_get);
  *          GSI interrupts
  */
 void __init acpi_set_irq_model(enum acpi_irq_model_id model,
-			       struct fwnode_handle *fwnode)
+			       struct fwnode_handle *(*fn)(u32))
 {
 	acpi_irq_model =3D model;
-	acpi_gsi_domain_id =3D fwnode;
+	acpi_get_gsi_domain_id =3D fn;
 }
=20
 /**
@@ -312,8 +317,14 @@ struct irq_domain *acpi_irq_create_hierarchy(unsigned =
int flags,
 					     const struct irq_domain_ops *ops,
 					     void *host_data)
 {
-	struct irq_domain *d =3D irq_find_matching_fwnode(acpi_gsi_domain_id,
-							DOMAIN_BUS_ANY);
+	struct irq_domain *d;
+
+	/* This only works for the GIC model... */
+	if (acpi_irq_model !=3D ACPI_IRQ_MODEL_GIC)
+		return NULL;
+
+	d =3D irq_find_matching_fwnode(acpi_get_gsi_domain_id(0),
+				     DOMAIN_BUS_ANY);
=20
 	if (!d)
 		return NULL;
diff --git a/drivers/irqchip/irq-gic-v3.c b/drivers/irqchip/irq-gic-v3.c
index 2be8dea6b6b0..87b1f53a65ec 100644
--- a/drivers/irqchip/irq-gic-v3.c
+++ b/drivers/irqchip/irq-gic-v3.c
@@ -2357,11 +2357,17 @@ static void __init gic_acpi_setup_kvm_info(void)
 	vgic_set_kvm_info(&gic_v3_kvm_info);
 }
=20
+static struct fwnode_handle *gsi_domain_handle;
+
+static struct fwnode_handle *gic_v3_get_gsi_domain_id(u32 gsi)
+{
+	return gsi_domain_handle;
+}
+
 static int __init
 gic_acpi_init(union acpi_subtable_headers *header, const unsigned long end)
 {
 	struct acpi_madt_generic_distributor *dist;
-	struct fwnode_handle *domain_handle;
 	size_t size;
 	int i, err;
=20
@@ -2393,18 +2399,18 @@ gic_acpi_init(union acpi_subtable_headers *header, =
const unsigned long end)
 	if (err)
 		goto out_redist_unmap;
=20
-	domain_handle =3D irq_domain_alloc_fwnode(&dist->base_address);
-	if (!domain_handle) {
+	gsi_domain_handle =3D irq_domain_alloc_fwnode(&dist->base_address);
+	if (!gsi_domain_handle) {
 		err =3D -ENOMEM;
 		goto out_redist_unmap;
 	}
=20
 	err =3D gic_init_bases(acpi_data.dist_base, acpi_data.redist_regs,
-			     acpi_data.nr_redist_regions, 0, domain_handle);
+			     acpi_data.nr_redist_regions, 0, gsi_domain_handle);
 	if (err)
 		goto out_fwhandle_free;
=20
-	acpi_set_irq_model(ACPI_IRQ_MODEL_GIC, domain_handle);
+	acpi_set_irq_model(ACPI_IRQ_MODEL_GIC, gic_v3_get_gsi_domain_id);
=20
 	if (static_branch_likely(&supports_deactivate_key))
 		gic_acpi_setup_kvm_info();
@@ -2412,7 +2418,7 @@ gic_acpi_init(union acpi_subtable_headers *header, co=
nst unsigned long end)
 	return 0;
=20
 out_fwhandle_free:
-	irq_domain_free_fwnode(domain_handle);
+	irq_domain_free_fwnode(gsi_domain_handle);
 out_redist_unmap:
 	for (i =3D 0; i < acpi_data.nr_redist_regions; i++)
 		if (acpi_data.redist_regs[i].redist_base)
diff --git a/drivers/irqchip/irq-gic.c b/drivers/irqchip/irq-gic.c
index 820404cb56bc..4c7bae0ec8f9 100644
--- a/drivers/irqchip/irq-gic.c
+++ b/drivers/irqchip/irq-gic.c
@@ -1682,11 +1682,17 @@ static void __init gic_acpi_setup_kvm_info(void)
 	vgic_set_kvm_info(&gic_v2_kvm_info);
 }
=20
+static struct fwnode_handle *gsi_domain_handle;
+
+static struct fwnode_handle *gic_v2_get_gsi_domain_id(u32 gsi)
+{
+	return gsi_domain_handle;
+}
+
 static int __init gic_v2_acpi_init(union acpi_subtable_headers *header,
 				   const unsigned long end)
 {
 	struct acpi_madt_generic_distributor *dist;
-	struct fwnode_handle *domain_handle;
 	struct gic_chip_data *gic =3D &gic_data[0];
 	int count, ret;
=20
@@ -1724,22 +1730,22 @@ static int __init gic_v2_acpi_init(union acpi_subta=
ble_headers *header,
 	/*
 	 * Initialize GIC instance zero (no multi-GIC support).
 	 */
-	domain_handle =3D irq_domain_alloc_fwnode(&dist->base_address);
-	if (!domain_handle) {
+	gsi_domain_handle =3D irq_domain_alloc_fwnode(&dist->base_address);
+	if (!gsi_domain_handle) {
 		pr_err("Unable to allocate domain handle\n");
 		gic_teardown(gic);
 		return -ENOMEM;
 	}
=20
-	ret =3D __gic_init_bases(gic, domain_handle);
+	ret =3D __gic_init_bases(gic, gsi_domain_handle);
 	if (ret) {
 		pr_err("Failed to initialise GIC\n");
-		irq_domain_free_fwnode(domain_handle);
+		irq_domain_free_fwnode(gsi_domain_handle);
 		gic_teardown(gic);
 		return ret;
 	}
=20
-	acpi_set_irq_model(ACPI_IRQ_MODEL_GIC, domain_handle);
+	acpi_set_irq_model(ACPI_IRQ_MODEL_GIC, gic_v2_get_gsi_domain_id);
=20
 	if (IS_ENABLED(CONFIG_ARM_GIC_V2M))
 		gicv2m_init(NULL, gic_data[0].domain);
diff --git a/include/linux/acpi.h b/include/linux/acpi.h
index 4f82a5bc6d98..957e23f727ea 100644
--- a/include/linux/acpi.h
+++ b/include/linux/acpi.h
@@ -356,7 +356,7 @@ int acpi_gsi_to_irq (u32 gsi, unsigned int *irq);
 int acpi_isa_irq_to_gsi (unsigned isa_irq, u32 *gsi);
=20
 void acpi_set_irq_model(enum acpi_irq_model_id model,
-			struct fwnode_handle *fwnode);
+			struct fwnode_handle *(*)(u32));
=20
 struct irq_domain *acpi_irq_create_hierarchy(unsigned int flags,
 					     unsigned int size,
--=20
2.34.1


--=20
Without deviation from the norm, progress is not possible.
